== Using Scopes

Koin brings a simple API to let you define instances that are tied to a limit lifetime.

=== What is a Scope in general?

Scope is a fixed duration of time or method calls in which an object exists.
Another way to look at this is to think of scope as the amount of time an objectâ€™s state persists.
When the scope context ends, any objects bound under that scope cannot be injected again (they are dropped from the container).

The Scope API mainly consists of three constructs:

- `Scope Set`
- `Scope Instance`
- `Scope Definition`

=== What is a ScopeSet?

A `Scope set` is a container for declaring the properties of a scope along with its definitions.
You can think of a `ScopeSet` as a blueprint for `Scope Instance`s.
[source,kotlin]
----
module {
    scope(named("A Scope Name")){
        // definitions
    }
}
----

=== What is a Scope Instance?
A Scope instance is a specific instance of a specified ScopeSet.

[source,kotlin]
----
val scope1 = koin.createScope("scopeId1","A Scope Name")
val scope2 = koin.createScope("scopeId2","A Scope Name")
----

Each `Scope instance` has a unique id assigned. This id has to be unique across the whole `KoinApplication` instance.

=== Scope definition

By default in Koin, we have 3 kind of definitions:

- `single` definition, create an object that persistent with the entire container lifetime (can't be dropped).
- `factory` definition, create a new object each time. Short live. No persistence in the container (can't be shared).
- `scoped` definition, create an object that persistent tied to the associated scope lifetime.

To declare a scoped definition, use the `scoped` function like follow. A scope gathers scoped definitions as a logical unit of time:

[source,kotlin]
----
module {
    scope(named("A Scope Name")){
        scoped { Presenter() }
        // ...
    }
}
----

=== Working with a scope

A scope instance can be created with as follow: `val scope = koin.createScope("myScope")`. The "myScope" string here, is the id of your scope instance. 

To resolve a dependency using the scope we can do it like:

* `val presenter = scope.get<Presenter>()` - directly using the get/inject functions from the scope instance

We have to declare a the scope instance like follow:

[source,kotlin]
----
// create scope instance "myScope" (the scope Id) for scope "A_SCOPE_NAME" (the qualifier)
val scope = koin.createScope("myScope","A_SCOPE_NAME")
// resolve presenter instance
val presenter = scope.get<Presenter>()
----

=== Create & retrieve a scope

From a `KoinComponent` class or where you can access your Koin instance:

- `createScope(id : ScopeID, scopeName : Qualifier)` - create a closed scope instance with given id and scopeName
- `getScope(id : ScopeID)` - retrieve a previously created scope with given id
- `getOrCreateScope(id : ScopeID, scopeName : Qualifier)` - create or retrieve if already created, the closed scope instance with given id and scopeName

[IMPORTANT]
====
Make the difference between a scope instance id, which is the id to find your scope over all your scopes, and the scope name, which is the reference to the tied scope group name.
====

=== Creating scope instances

Using the id, it's then possible to have several instances of the same scope:

[source,kotlin]
----
// create an closed scope instance "myScope1" for scope "A_SCOPE_NAME"
val myScope1 = koin.createScope("myScope1",named("A_SCOPE_NAME"))
// create an closed scope instance "myScope2" for scope "A_SCOPE_NAME"
val myScope2 = koin.createScope("myScope2",named("A_SCOPE_NAME"))
----


=== Resolving dependencies within a scope

The interest of a scope is to define a common logical unit of time for scoped definitions. It's allow also to resolve definitions from within the given scope

[source,kotlin]
----
// given the classes
class ComponentA
class ComponentB(val a : ComponentA)

// module with scope
module {
    
    scope(named("A_SCOPE_NAME")){
        scoped { ComponentA() }
        // will resolve from current scope instance
        scoped { ComponentB(get()) }
    }
}
----

The dependency resolution is then straight forward:

[source,kotlin]
----
// create an closed scope instance "myScope1" for scope "A_SCOPE_NAME"
val myScope1 = koin.createScope("myScope1",named("A_SCOPE_NAME"))

// from the same scope
val componentA = myScope1.get<ComponentA>()
val componentB = myScope1.get<ComponentB>()
----

=== Closing a scope

Once your scope instance is finished, just closed it with the `close()` function:

[source,kotlin]
----
// from a KoinComponent
val session = getKoin().createScope("session")

// use it ...

// close it
session.close()
----

[IMPORTANT]
====
Beware that you can't inject instances anymore from a closed scope.
====

=== Object Scopes

An `object scope` is a special type of scope
which references the actual instance demanding the scope. A user session for example might consist of the actual user, lifetime of the session and several other functionality.
Now several components might depend on the user session. By using an `object scope`, the user session is known to koin during resolution.

[source,kotlin]
----
interface UserSession
class AuthenticatedUserSession: UserSession()
class AnonymousUserSession: UserSession()
// from a KoinComponent
module {
    objectScope<UserSession> {
        scoped { UserSpecificService(get<UserSession>())}
    }
}
val scopeAuthenticated = koin.createObjectScoped(authenticatedSession)
val scopeAnonymous = koin.createObjectScoped(anonymousSession)
----

=== Scope Hierarchies

During scope instance creation, the id of the parent scope can be provided.
When no id for the parent scope is specified, the root scope will be assigned as the parent scope.

[source,kotlin]
----
module {
    scope(named("Scope A")) {
        scoped { PresenterA() }
    }
    scope(named("Scope B")) {
        // Either resolve explicitly from parent
        scoped { PresenterB( parentScope.get<PresenterA>()) }
        // Or resolving from current scope
        scoped { PresenterB( get<PresenterA>()) }
    }
}

val scopeA = koin.createScope("id1", "Scope A")
val scopeB = koin.createScope("id2", "Scope B", parentId = "id1")
----

[IMPORTANT]
====
Beware that the resolution of `PresenterA` in this example will fail, when the parentId for `Scope B` is not provided.
====

=== Parent Scope Validation
To ensure that the correct parent scope is provided to a child scope, we can use the DSL for child scopes inside a ScopeSet:

[source,kotlin]
----
module {
    scope(named("Scope A1")) {
        scoped { PresenterA() }
        childScope(named("Scope B")) {
            scoped { PresenterB( get<PresenterA>()) }
        }
    }
    scope(named("Scope A2")) { }
}
----

Passing Example
[source, kotlin]
Creation of `scopeB` will succeed because the parent scope is the expected "Scope A1".
----
val scopeA1 = koin.createScope("id1", "Scope A1")
// This will succeed because the parent scope is the expected "Scope A1"
val scopeB = koin.createScope("id2", "Scope B", parentId = "id1")
----

Failing Example

Creation of `scopeB` will fail because the parent scope is not the expected "Scope A1", but "Scope A2".

[source, kotlin]
----
val scopeA2 = koin.createScope("id1", "Scope A2")
val scopeB = koin.createScope("id2", "Scope B", parentId = "id1")
----

[IMPORTANT]
====
Beware that this validation doesn't work for ScopeSets across modules.
====

=== Scope callback -- TODO